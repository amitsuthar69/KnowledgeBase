QUICK DBMS NOTES
  
1. Definition:
  - A Database Management System is software that provides an interface to create, manage, and manipulate databases.
  - Purpose: To store, retrieve, update, and manage data efficiently while ensuring data integrity and security.

2. DBMS Components
  - Hardware: Physical devices (servers, disks, I/O devices) used to store and process data.
  - Software: The DBMS engine and associated programs (utilities, drivers).
  - Data: Actual data plus metadata (data about data).
  - Procedures: Rules and guidelines on how to use and maintain the database.
  - Database Languages:
    - DDL (Data Definition Language): CREATE, ALTER, DROP, etc.
    - DML (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
    - DCL (Data Control Language): GRANT, REVOKE
    - TCL (Transaction Control Language): COMMIT, ROLLBACK
  - Users: DB Admins, application programmers, end-users, data analysts, etc.

3. Key Concepts and Terminologies
  - ACID Properties:
    - Atomicity: All-or-nothing transactions.
    - Consistency: Transactions preserve database rules.
    - Isolation: Concurrent transactions do not interfere.
    - Durability: Once committed, changes are permanent.
  
  - Normalization: Process of organizing data to reduce redundancy (1NF, 2NF, 3NF, BCNF).
      - It is the process of designing a relational database schema so that:
        - Redundancy is minimized: The same piece of data isn’t stored in multiple places.
        - Data integrity is maintained: Updates, inserts, and deletes can occur without causing inconsistencies.
        - Dependencies are logical: Each piece of data is stored only once and its relationships to other data are well-defined.
      - Forms:
        Normalization is typically performed in several steps or “normal forms,” each with stricter rules:
        
        - First Normal Form (1NF):
          - A table is in 1NF if it contains only atomic values and each record is unique.
          - Has a composite primary key (eg: _id).
          - No duplicate rows or columns.
            - eg: Instead of storing phone numbers as a comma-separated list in one field, 
                  each phone number should be in its own record or column.

        - Second Normal Form (2NF):
          - Every non-key column must depend on the entire primary key (if the key is made of more than one column).
            - eg: In a table with a composite key (e.g., OrderID and ProductID), details like ProductName should only 
            depend on ProductID and should be moved to a separate Product table.
        
        - Third Normal Form (3NF):
          - Non-key columns should depend only on the primary key, not on other non-key columns.

        - Fourth Normal Form (4NF):
          - Avoid storing two independent sets of data in the same table (like a student’s courses and hobbies together).

        - Fifth Normal Form (5NF):
          - Make sure the table can’t be split into smaller tables without losing important relationships.

  - Database Views:
    - A view is a virtual table created by a SELECT query. 
    - It does not store data itself, but presents data from one or more tables in a structured way. 
    - Views simplify complex queries and enhance security by restricting access to specific rows or columns.

  - Operators available in SQL:
    - Arithmetic Operators: +, -, *, /, %
    - Comparison Operators: =, !=, <>, >, <, >=, <=
    - Logical Operators: AND, OR, NOT
    - Set Operators: UNION, INTERSECT, EXCEPT
    - Special Operators: BETWEEN, IN, LIKE, IS NULL

  - DELETE: Removes rows one at a time and records each deletion in the transaction log, allowing rollback. 
            Can have a WHERE clause.
  - TRUNCATE: Removes all rows at once without logging individual row deletions. 
              It cannot have a WHERE clause and is faster than DELETE for large data sets.

  - Keys:
    - Primary Key: Uniquely identifies records which cannot be NULL.
    - Foreign Key: References primary key in another table. It can be NULL.
    - Candidate Key: A minimal set of attributes for unique identification. Can become a primary key.
    - Alternate Key: A candidate key which isn't chosen as a Primary Key.
    - Super Key: A set of attributes that uniquely identifies records. Any combination that guarantees uniqueness.
    - Unique Key: Ensures all values in a column are unique. Similar to primary key but allows NULL.
    - Composite Key: Combination of two or more columns as a primary key. 
                     Used when no single column can uniquely identify records.

    - Types of constraints in SQL:
      - NOT NULL: Ensures a column cannot have NULL values.
      - UNIQUE: Ensures all values in a column are distinct.
      - PRIMARY KEY: Uniquely identifies each row in a table.
      - FOREIGN KEY: Ensures referential integrity by linking to a primary key in another table.
      - CHECK: Ensures that all values in a column satisfy a specific condition.
      - DEFAULT: Sets a default value for a column when no value is specified.


  - Aggregate functions in SQL
    - Perform calculations on a set of values and return a single value.
      - COUNT(): Number of rows.
      - SUM(): Total sum of values.
      - AVG(): Average of values.
      - MIN(): Smallest value.
      - MAX(): Largest value.
  
  - Indexing: (A lookup table for specific colums)
    - It is a data structure technique used to locate and quickly access data in databases.
    - Several database fields are used to generate indexes. 
    - The main key or candidate key of the table is duplicated in the first column, which is the Search key. 
    - To speed up data retrieval, the values are also kept in sorted order. 
    - It should be highlighted that sorting the data is not required. 
    - The second column is the Data Reference or Pointer which contains a set of pointers holding the address 
      of the disk block where that particular key value can be found.
    - Indexing improves database performance by minimizing the number of disc visits required to fulfill a query. 
    - Dense Index and Sparse Index
  
  - Joins: Combining rows from two or more tables (INNER, LEFT, RIGHT, FULL, self-joins, cross joins).
    - Retrive Data from multiple related tables.
		- Minimizes duplicate data storage across tables.
		- Optimizes operations for faster queries.
		- Types of JOINS: (https://sql-joins.leopard.in.ua/)
			- INNER JOIN -> Returns only matching rows. If no match found, NULL is returned.
			- LEFT JOIN  -> Returns all rows from the left table and matching ones from the right.
			- RIGHT JOIN -> Returns all rows from the right table and matching ones from the left.
			- FULL OUTER JOIN  -> Returns all rows when there's a match in either table.
			- CROSS JOIN -> Froms every possible combination of rows. Used to get cartesian product (all x all)
			- NATURAL JOIN -> Automatically detecting and joining tables on colums with same name.
											  Can cause unintended matches. Unlike CROSS join, it ensures only matching colums are included
  - Locking Mechanisms:
    - Shared Locks: For reading.
    - Exclusive Locks: For writing.

3. Popular Database Types:
  i. Relational Databases: 
	  - Store data in structured tables.
    - Schema & Query Language: Uses a fixed schema and SQL to perform CRUD operations.
    - ACID Compliance: Ensures transactions are Atomic, Consistent, Isolated, and Durable.
    - Use Cases: Ideal for applications with structured data and well-defined relationships:
                 like banking systems, inventory management, and ERP systems.
	  - eg: MySQL, Postgre SQL, Oracle.
    - type of indexes:
      - B‑Tree Indexes: The default index type used for most queries (e.g., WHERE clauses, range queries, ORDER BY).
      - Full-Text Indexes: Specialized indexes designed for searching textual data within large text columns.
      - Spatial Indexes: Used for geometry data types to optimize spatial queries.

  ii. Document Store:
    - Data is stored as documents (usually in JSON, BSON, or XML format) which can contain nested structures.
    - Schema Flexibility: Schemas are dynamic—each document can have a different structure, 
                          making it ideal for evolving data models.
    - Querying: Supports rich queries on document content, indexing, and aggregation.
    - Use Cases: Well-suited for content management systems, real-time analytics, and applications with semi-structured data.
    - Examples: MongoDB, CouchDB.
    - type of indexes:
      - Single Field Indexes: Indexes created on one field in a document.
      - Compound Indexes: Indexes on multiple fields, which are useful when queries filter on more than one field.
      - Multikey Indexes: Special indexes that allow MongoDB to index fields that contain arrays.
      - Text Indexes: Designed for performing full-text search queries on string content.
      - Geospatial Indexes: Optimize queries that involve location-based data, such as proximity searches.

  iii. Key-Value Databases:
    - Data is stored as a simple key-value pair, similar to a dictionary or hash table.
    - Performance: Extremely fast for lookups when the key is known; minimal overhead in data retrieval.
    - Flexibility: Keys can reference simple values, complex objects, or even serialized data.
    - Use Cases: Commonly used for caching, session management, and scenarios where rapid access to data is critical.
    - Examples: Redis, Amazon DynamoDB (in its key-value use case), Riak KV.

  iv. Graph Databases:
    - Data is represented as nodes (entities) and edges (relationships) along with properties for both.
    - Relationships: Optimized to handle complex relationships and interconnected data, 
                     allowing efficient traversal and pattern matching.
    - Querying: Uses graph query languages (e.g., Cypher) to navigate relationships and perform analytics.
    - Use Cases: Excellent for social networks, recommendation systems, fraud detection, and network analysis.
    - Examples: Neo4j, JanusGraph, Amazon Neptune.